"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

// Import ABI and addresses (will be generated by genabi script)
// For now, we'll use a placeholder - these should be generated after deployment
import { EcoTraceAddresses } from "@/abi/EcoTraceAddresses";
import { EcoTraceABI } from "@/abi/EcoTraceABI";

export type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};

type EcoTraceInfoType = {
  abi: typeof EcoTraceABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

function getEcoTraceByChainId(
  chainId: number | undefined
): EcoTraceInfoType {
  if (!chainId) {
    return { abi: EcoTraceABI.abi };
  }

  const entry =
    EcoTraceAddresses[chainId.toString() as keyof typeof EcoTraceAddresses];

  if (!entry || entry.address === ethers.ZeroAddress) {
    return { abi: EcoTraceABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: EcoTraceABI.abi,
  };
}

export const useEcoTrace = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  const [carbonScoreHandle, setCarbonScoreHandle] = useState<
    string | undefined
  >(undefined);
  const [clearCarbonScore, setClearCarbonScore] = useState<
    ClearValueType | undefined
  >(undefined);
  const clearCarbonScoreRef = useRef<ClearValueType>(undefined);
  const [isRefreshing, setIsRefreshing] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<boolean>(false);
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");

  const ecoTraceRef = useRef<EcoTraceInfoType | undefined>(undefined);
  const isRefreshingRef = useRef<boolean>(isRefreshing);
  const isDecryptingRef = useRef<boolean>(isDecrypting);
  const isSubmittingRef = useRef<boolean>(isSubmitting);

  const isDecrypted =
    carbonScoreHandle && carbonScoreHandle === clearCarbonScore?.handle;

  const ecoTrace = useMemo(() => {
    const c = getEcoTraceByChainId(chainId);
    ecoTraceRef.current = c;
    if (chainId !== undefined && !c.address) {
      setMessage(`EcoTrace contract not deployed on chainId=${chainId}.`);
    } else {
      setMessage("");
    }
    return c;
  }, [chainId]);

  const isDeployed = useMemo(() => {
    if (!ecoTrace) {
      return undefined;
    }
    return (
      Boolean(ecoTrace.address) && ecoTrace.address !== ethers.ZeroAddress
    );
  }, [ecoTrace]);

  const canGetCarbonScore = useMemo(() => {
    return ecoTrace.address && ethersSigner && !isRefreshing;
  }, [ecoTrace.address, ethersSigner, isRefreshing]);

  const refreshCarbonScoreHandle = useCallback(() => {
    console.log("[useEcoTrace] call refreshCarbonScoreHandle()");
    if (isRefreshingRef.current) {
      return;
    }

    if (
      !ecoTraceRef.current ||
      !ecoTraceRef.current?.chainId ||
      !ecoTraceRef.current?.address ||
      !ethersSigner
    ) {
      setCarbonScoreHandle(undefined);
      return;
    }

    isRefreshingRef.current = true;
    setIsRefreshing(true);

    const thisChainId = ecoTraceRef.current.chainId;
    const thisEcoTraceAddress = ecoTraceRef.current.address;
    const thisEthersSigner = ethersSigner;

    const thisEcoTraceContract = new ethers.Contract(
      thisEcoTraceAddress,
      ecoTraceRef.current.abi,
      thisEthersSigner
    );

    thisEcoTraceContract
      .getCarbonScore()
      .then((value) => {
        console.log("[useEcoTrace] getCarbonScore()=" + value);
        if (
          sameChain.current(thisChainId) &&
          thisEcoTraceAddress === ecoTraceRef.current?.address &&
          sameSigner.current(thisEthersSigner)
        ) {
          setCarbonScoreHandle(value);
        }

        isRefreshingRef.current = false;
        setIsRefreshing(false);
      })
      .catch((e) => {
        setMessage("EcoTrace.getCarbonScore() call failed! error=" + e);
        isRefreshingRef.current = false;
        setIsRefreshing(false);
      });
  }, [ethersSigner, sameChain, sameSigner]);

  useEffect(() => {
    refreshCarbonScoreHandle();
  }, [refreshCarbonScoreHandle]);

  const canDecrypt = useMemo(() => {
    return (
      ecoTrace.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isDecrypting &&
      carbonScoreHandle &&
      carbonScoreHandle !== ethers.ZeroHash &&
      carbonScoreHandle !== clearCarbonScore?.handle
    );
  }, [
    ecoTrace.address,
    instance,
    ethersSigner,
    isRefreshing,
    isDecrypting,
    carbonScoreHandle,
    clearCarbonScore,
  ]);

  const decryptCarbonScoreHandle = useCallback(() => {
    if (isRefreshingRef.current || isDecryptingRef.current) {
      return;
    }

    if (!ecoTrace.address || !instance || !ethersSigner) {
      return;
    }

    if (carbonScoreHandle === clearCarbonScoreRef.current?.handle) {
      return;
    }

    if (!carbonScoreHandle) {
      setClearCarbonScore(undefined);
      clearCarbonScoreRef.current = undefined;
      return;
    }

    if (carbonScoreHandle === ethers.ZeroHash) {
      setClearCarbonScore({ handle: carbonScoreHandle, clear: BigInt(0) });
      clearCarbonScoreRef.current = { handle: carbonScoreHandle, clear: BigInt(0) };
      return;
    }

    const thisChainId = chainId;
    const thisEcoTraceAddress = ecoTrace.address;
    const thisCarbonScoreHandle = carbonScoreHandle;
    const thisEthersSigner = ethersSigner;

    isDecryptingRef.current = true;
    setIsDecrypting(true);
    setMessage("Start decrypt");

    const run = async () => {
      const isStale = () =>
        thisEcoTraceAddress !== ecoTraceRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        const sig: FhevmDecryptionSignature | null =
          await FhevmDecryptionSignature.loadOrSign(
            instance,
            [ecoTrace.address as `0x${string}`],
            ethersSigner,
            fhevmDecryptionSignatureStorage
          );

        if (!sig) {
          setMessage("Unable to build FHEVM decryption signature");
          return;
        }

        if (isStale()) {
          setMessage("Ignore FHEVM decryption");
          return;
        }

        setMessage("Call FHEVM userDecrypt...");

        const res = await instance.userDecrypt(
          [
            {
              handle: thisCarbonScoreHandle,
              contractAddress: thisEcoTraceAddress,
            },
          ],
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );

        setMessage("FHEVM userDecrypt completed!");

        if (isStale()) {
          setMessage("Ignore FHEVM decryption");
          return;
        }

        setClearCarbonScore({
          handle: thisCarbonScoreHandle,
          clear: res[thisCarbonScoreHandle] as string | bigint | boolean,
        });
        clearCarbonScoreRef.current = {
          handle: thisCarbonScoreHandle,
          clear: res[thisCarbonScoreHandle] as string | bigint | boolean,
        };

        setMessage(
          "Carbon score clear value is " + clearCarbonScoreRef.current.clear
        );
      } finally {
        isDecryptingRef.current = false;
        setIsDecrypting(false);
      }
    };

    run();
  }, [
    fhevmDecryptionSignatureStorage,
    ethersSigner,
    ecoTrace.address,
    instance,
    carbonScoreHandle,
    chainId,
    sameChain,
    sameSigner,
  ]);

  const canSubmit = useMemo(() => {
    return (
      ecoTrace.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isSubmitting
    );
  }, [ecoTrace.address, instance, ethersSigner, isRefreshing, isSubmitting]);

  const submitTravelData = useCallback(
    (distance: number, travelMode: number) => {
      if (isRefreshingRef.current || isSubmittingRef.current) {
        return;
      }

      if (!ecoTrace.address || !instance || !ethersSigner) {
        return;
      }

      const thisChainId = chainId;
      const thisEcoTraceAddress = ecoTrace.address;
      const thisEthersSigner = ethersSigner;
      const thisEcoTraceContract = new ethers.Contract(
        thisEcoTraceAddress,
        ecoTrace.abi,
        thisEthersSigner
      );

      isSubmittingRef.current = true;
      setIsSubmitting(true);
      setMessage(`Start submitTravelData(distance=${distance}, mode=${travelMode})...`);

      const run = async () => {
        await new Promise((resolve) => setTimeout(resolve, 100));

        const isStale = () =>
          thisEcoTraceAddress !== ecoTraceRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          // Encrypt distance
          const distanceInput = instance.createEncryptedInput(
            thisEcoTraceAddress as `0x${string}`,
            thisEthersSigner.address as `0x${string}`
          );
          distanceInput.add32(distance);
          const distanceEnc = await distanceInput.encrypt();

          // Encrypt travel mode
          const modeInput = instance.createEncryptedInput(
            thisEcoTraceAddress as `0x${string}`,
            thisEthersSigner.address as `0x${string}`
          );
          modeInput.add32(travelMode);
          const modeEnc = await modeInput.encrypt();

          if (isStale()) {
            setMessage(`Ignore submitTravelData`);
            return;
          }

          setMessage(`Call submitTravelData...`);

          const tx: ethers.TransactionResponse =
            await thisEcoTraceContract.submitTravelData(
              distanceEnc.handles[0],
              distanceEnc.inputProof,
              modeEnc.handles[0],
              modeEnc.inputProof
            );

          setMessage(`Wait for tx:${tx.hash}...`);

          const receipt = await tx.wait();

          setMessage(
            `Call submitTravelData completed status=${receipt?.status}`
          );

          if (isStale()) {
            setMessage(`Ignore submitTravelData`);
            return;
          }

          refreshCarbonScoreHandle();
        } catch (e) {
          setMessage(`submitTravelData Failed! ${e}`);
        } finally {
          isSubmittingRef.current = false;
          setIsSubmitting(false);
        }
      };

      run();
    },
    [
      ethersSigner,
      ecoTrace.address,
      ecoTrace.abi,
      instance,
      chainId,
      refreshCarbonScoreHandle,
      sameChain,
      sameSigner,
    ]
  );

  const submitSpendData = useCallback(
    (spend: number, category: number) => {
      if (isRefreshingRef.current || isSubmittingRef.current) {
        return;
      }

      if (!ecoTrace.address || !instance || !ethersSigner) {
        return;
      }

      const thisChainId = chainId;
      const thisEcoTraceAddress = ecoTrace.address;
      const thisEthersSigner = ethersSigner;
      const thisEcoTraceContract = new ethers.Contract(
        thisEcoTraceAddress,
        ecoTrace.abi,
        thisEthersSigner
      );

      isSubmittingRef.current = true;
      setIsSubmitting(true);
      setMessage(`Start submitSpendData(spend=${spend}, category=${category})...`);

      const run = async () => {
        await new Promise((resolve) => setTimeout(resolve, 100));

        const isStale = () =>
          thisEcoTraceAddress !== ecoTraceRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          // Encrypt spend amount
          const spendInput = instance.createEncryptedInput(
            thisEcoTraceAddress as `0x${string}`,
            thisEthersSigner.address as `0x${string}`
          );
          spendInput.add32(spend);
          const spendEnc = await spendInput.encrypt();

          // Encrypt category
          const categoryInput = instance.createEncryptedInput(
            thisEcoTraceAddress as `0x${string}`,
            thisEthersSigner.address as `0x${string}`
          );
          categoryInput.add32(category);
          const categoryEnc = await categoryInput.encrypt();

          if (isStale()) {
            setMessage(`Ignore submitSpendData`);
            return;
          }

          setMessage(`Call submitSpendData...`);

          const tx: ethers.TransactionResponse =
            await thisEcoTraceContract.submitSpendData(
              spendEnc.handles[0],
              spendEnc.inputProof,
              categoryEnc.handles[0],
              categoryEnc.inputProof
            );

          setMessage(`Wait for tx:${tx.hash}...`);

          const receipt = await tx.wait();

          setMessage(`Call submitSpendData completed status=${receipt?.status}`);

          if (isStale()) {
            setMessage(`Ignore submitSpendData`);
            return;
          }

          refreshCarbonScoreHandle();
        } catch (e) {
          setMessage(`submitSpendData Failed! ${e}`);
        } finally {
          isSubmittingRef.current = false;
          setIsSubmitting(false);
        }
      };

      run();
    },
    [
      ethersSigner,
      ecoTrace.address,
      ecoTrace.abi,
      instance,
      chainId,
      refreshCarbonScoreHandle,
      sameChain,
      sameSigner,
    ]
  );

  return {
    contractAddress: ecoTrace.address,
    canDecrypt,
    canGetCarbonScore,
    canSubmit,
    submitTravelData,
    submitSpendData,
    decryptCarbonScoreHandle,
    refreshCarbonScoreHandle,
    isDecrypted,
    message,
    clear: clearCarbonScore?.clear,
    handle: carbonScoreHandle,
    isDecrypting,
    isRefreshing,
    isSubmitting,
    isDeployed,
  };
};

